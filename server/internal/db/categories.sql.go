// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: categories.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, type, "order", comment, user_id, icon, plan, color, plan_period)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
`

type CreateCategoryParams struct {
	Name       string                   `json:"name"`
	Type       CategoriesTypeEnum       `json:"type"`
	Order      int32                    `json:"order"`
	Comment    string                   `json:"comment"`
	UserID     int32                    `json:"userId"`
	Icon       string                   `json:"icon"`
	Plan       pgtype.Numeric           `json:"plan"`
	Color      string                   `json:"color"`
	PlanPeriod CategoriesPlanPeriodEnum `json:"planPeriod"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Name,
		arg.Type,
		arg.Order,
		arg.Comment,
		arg.UserID,
		arg.Icon,
		arg.Plan,
		arg.Color,
		arg.PlanPeriod,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :one
DELETE
FROM categories
WHERE id = $1
returning id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
`

func (q *Queries) DeleteCategory(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRow(ctx, deleteCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const getAdjustmentCategoryUserID = `-- name: GetAdjustmentCategoryUserID :one
SELECT id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
FROM categories
WHERE user_id = $1
  and type = 'adjustment'
`

func (q *Queries) GetAdjustmentCategoryUserID(ctx context.Context, userID int32) (Category, error) {
	row := q.db.QueryRow(ctx, getAdjustmentCategoryUserID, userID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const getCategoriesByIDAndUserIDs = `-- name: GetCategoriesByIDAndUserIDs :many
SELECT id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
FROM categories
WHERE id = ANY ($1::bigint[])
  and user_id = $2
order by type, "order"
`

type GetCategoriesByIDAndUserIDsParams struct {
	Column1 []int64 `json:"column1"`
	UserID  int32   `json:"userId"`
}

func (q *Queries) GetCategoriesByIDAndUserIDs(ctx context.Context, arg GetCategoriesByIDAndUserIDsParams) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategoriesByIDAndUserIDs, arg.Column1, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Type,
			&i.Order,
			&i.Comment,
			&i.UserID,
			&i.DeletedAt,
			&i.Icon,
			&i.Plan,
			&i.Color,
			&i.PlanPeriod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryByID = `-- name: GetCategoryByID :one
SELECT id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
FROM categories
WHERE id = $1
`

func (q *Queries) GetCategoryByID(ctx context.Context, id int64) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByID, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const getCategoryByIDAndUserID = `-- name: GetCategoryByIDAndUserID :one
SELECT id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
FROM categories
WHERE id = $1
  and user_id = $2
  and deleted_at is null
order by type, "order"
`

type GetCategoryByIDAndUserIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"userId"`
}

func (q *Queries) GetCategoryByIDAndUserID(ctx context.Context, arg GetCategoryByIDAndUserIDParams) (Category, error) {
	row := q.db.QueryRow(ctx, getCategoryByIDAndUserID, arg.ID, arg.UserID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const listCategoriesByUser = `-- name: ListCategoriesByUser :many
SELECT id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
FROM categories
WHERE user_id = $1
  and deleted_at is null
order by type, "order"
`

func (q *Queries) ListCategoriesByUser(ctx context.Context, userID int32) ([]Category, error) {
	rows, err := q.db.Query(ctx, listCategoriesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Type,
			&i.Order,
			&i.Comment,
			&i.UserID,
			&i.DeletedAt,
			&i.Icon,
			&i.Plan,
			&i.Color,
			&i.PlanPeriod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteCategory = `-- name: SoftDeleteCategory :one
UPDATE categories
SET deleted_at = now(),
    updated_at = now()
WHERE id = $1
  and user_id = $2
returning id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
`

type SoftDeleteCategoryParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"userId"`
}

func (q *Queries) SoftDeleteCategory(ctx context.Context, arg SoftDeleteCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, softDeleteCategory, arg.ID, arg.UserID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name        = $2,
    type        = $3,
    "order"     = $4,
    comment     = $5,
    icon        = $6,
    plan        = $7,
    color       = $8,
    plan_period = $9,
    updated_at  = now()
WHERE id = $1
  and user_id = $10
returning id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
`

type UpdateCategoryParams struct {
	ID         int64                    `json:"id"`
	Name       string                   `json:"name"`
	Type       CategoriesTypeEnum       `json:"type"`
	Order      int32                    `json:"order"`
	Comment    string                   `json:"comment"`
	Icon       string                   `json:"icon"`
	Plan       pgtype.Numeric           `json:"plan"`
	Color      string                   `json:"color"`
	PlanPeriod CategoriesPlanPeriodEnum `json:"planPeriod"`
	UserID     int32                    `json:"userId"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Type,
		arg.Order,
		arg.Comment,
		arg.Icon,
		arg.Plan,
		arg.Color,
		arg.PlanPeriod,
		arg.UserID,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}

const updateCategoryOrder = `-- name: UpdateCategoryOrder :one
UPDATE categories
SET "order"    = $1,
    updated_at = now()
WHERE id = $2
  and user_id = $3
returning id, created_at, updated_at, name, type, "order", comment, user_id, deleted_at, icon, plan, color, plan_period
`

type UpdateCategoryOrderParams struct {
	Order  int32 `json:"order"`
	ID     int64 `json:"id"`
	UserID int32 `json:"userId"`
}

func (q *Queries) UpdateCategoryOrder(ctx context.Context, arg UpdateCategoryOrderParams) (Category, error) {
	row := q.db.QueryRow(ctx, updateCategoryOrder, arg.Order, arg.ID, arg.UserID)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Type,
		&i.Order,
		&i.Comment,
		&i.UserID,
		&i.DeletedAt,
		&i.Icon,
		&i.Plan,
		&i.Color,
		&i.PlanPeriod,
	)
	return i, err
}
