// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: records.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecord = `-- name: CreateRecord :one
WITH inserted AS (
    INSERT INTO records (amount, comment, timestamp, category_id)
        VALUES ($1, $2, $3, $4)
        RETURNING id, created_at, updated_at, amount, comment, timestamp, category_id, deleted_at)
SELECT inserted.id, inserted.created_at, inserted.updated_at, inserted.amount, inserted.comment, inserted.timestamp, inserted.category_id, inserted.deleted_at, c.type as type
FROM inserted
         JOIN categories c ON c.id = inserted.category_id
`

type CreateRecordParams struct {
	Amount     pgtype.Numeric   `json:"amount"`
	Comment    string           `json:"comment"`
	Timestamp  pgtype.Timestamp `json:"timestamp"`
	CategoryID int64            `json:"categoryId"`
}

type CreateRecordRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (CreateRecordRow, error) {
	row := q.db.QueryRow(ctx, createRecord,
		arg.Amount,
		arg.Comment,
		arg.Timestamp,
		arg.CategoryID,
	)
	var i CreateRecordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const deleteRecord = `-- name: DeleteRecord :one
with deleted as ( DELETE
    FROM records
        WHERE records.id = $1
        returning id, created_at, updated_at, amount, comment, timestamp, category_id, deleted_at)
SELECT d.id, d.created_at, d.updated_at, d.amount, d.comment, d.timestamp, d.category_id, d.deleted_at, c.type as type
FROM deleted d
         JOIN categories c ON c.id = d.category_id
`

type DeleteRecordRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) DeleteRecord(ctx context.Context, id int64) (DeleteRecordRow, error) {
	row := q.db.QueryRow(ctx, deleteRecord, id)
	var i DeleteRecordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const getRecordByID = `-- name: GetRecordByID :one
SELECT r.id, r.created_at, r.updated_at, r.amount, r.comment, r.timestamp, r.category_id, r.deleted_at, c.type as type
FROM records as r
         join categories as c on r.category_id = c.id
WHERE r.id = $1
  and r.deleted_at is null
`

type GetRecordByIDRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) GetRecordByID(ctx context.Context, id int64) (GetRecordByIDRow, error) {
	row := q.db.QueryRow(ctx, getRecordByID, id)
	var i GetRecordByIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const getRecordByIDAndUserID = `-- name: GetRecordByIDAndUserID :one
SELECT r.id, r.created_at, r.updated_at, r.amount, r.comment, r.timestamp, r.category_id, r.deleted_at, c.type as type
FROM records as r
         join categories as c on r.category_id = c.id
WHERE r.id = $1
  and r.deleted_at is null
  and c.deleted_at is null
  and c.user_id = $2
`

type GetRecordByIDAndUserIDParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"userId"`
}

type GetRecordByIDAndUserIDRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) GetRecordByIDAndUserID(ctx context.Context, arg GetRecordByIDAndUserIDParams) (GetRecordByIDAndUserIDRow, error) {
	row := q.db.QueryRow(ctx, getRecordByIDAndUserID, arg.ID, arg.UserID)
	var i GetRecordByIDAndUserIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const listRecordByUserID = `-- name: ListRecordByUserID :many
SELECT r.id, r.created_at, r.updated_at, r.amount, r.comment, r.timestamp, r.category_id, r.deleted_at, c.type as type
FROM records as r
         join categories as c on r.category_id = c.id
WHERE c.user_id = $1
  and r.deleted_at is null
  and c.deleted_at is null
order by timestamp desc
`

type ListRecordByUserIDRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) ListRecordByUserID(ctx context.Context, userID int32) ([]ListRecordByUserIDRow, error) {
	rows, err := q.db.Query(ctx, listRecordByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordByUserIDRow
	for rows.Next() {
		var i ListRecordByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Amount,
			&i.Comment,
			&i.Timestamp,
			&i.CategoryID,
			&i.DeletedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordsByCategory = `-- name: ListRecordsByCategory :many
SELECT r.id, r.created_at, r.updated_at, r.amount, r.comment, r.timestamp, r.category_id, r.deleted_at, c.type as type
FROM records as r
         join categories as c on r.category_id = c.id
WHERE r.category_id = $1
  and c.deleted_at is null
`

type ListRecordsByCategoryRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) ListRecordsByCategory(ctx context.Context, categoryID int64) ([]ListRecordsByCategoryRow, error) {
	rows, err := q.db.Query(ctx, listRecordsByCategory, categoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordsByCategoryRow
	for rows.Next() {
		var i ListRecordsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Amount,
			&i.Comment,
			&i.Timestamp,
			&i.CategoryID,
			&i.DeletedAt,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteRecord = `-- name: SoftDeleteRecord :one
UPDATE records
SET deleted_at = now(),
    updated_at = now()
from categories as c
WHERE c.id = records.category_id
  and records.id = $1
  and c.user_id = $2
returning records.id, records.created_at, records.updated_at, records.amount, records.comment, records.timestamp, records.category_id, records.deleted_at, c.type as type
`

type SoftDeleteRecordParams struct {
	ID     int64 `json:"id"`
	UserID int32 `json:"userId"`
}

type SoftDeleteRecordRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) SoftDeleteRecord(ctx context.Context, arg SoftDeleteRecordParams) (SoftDeleteRecordRow, error) {
	row := q.db.QueryRow(ctx, softDeleteRecord, arg.ID, arg.UserID)
	var i SoftDeleteRecordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const updateRecord = `-- name: UpdateRecord :one
WITH updated AS (
    UPDATE records
        SET amount = $1,
            comment = $2,
            timestamp = $3,
            category_id = $4,
            updated_at = now()
        WHERE records.id = $5
        RETURNING id, created_at, updated_at, amount, comment, timestamp, category_id, deleted_at)
SELECT u.id, u.created_at, u.updated_at, u.amount, u.comment, u.timestamp, u.category_id, u.deleted_at, c.type as type
FROM updated u
         JOIN categories c ON c.id = u.category_id
`

type UpdateRecordParams struct {
	Amount     pgtype.Numeric   `json:"amount"`
	Comment    string           `json:"comment"`
	Timestamp  pgtype.Timestamp `json:"timestamp"`
	CategoryID int64            `json:"categoryId"`
	ID         int64            `json:"id"`
}

type UpdateRecordRow struct {
	ID         int64              `json:"id"`
	CreatedAt  pgtype.Timestamp   `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp   `json:"updatedAt"`
	Amount     pgtype.Numeric     `json:"amount"`
	Comment    string             `json:"comment"`
	Timestamp  pgtype.Timestamp   `json:"timestamp"`
	CategoryID int64              `json:"categoryId"`
	DeletedAt  pgtype.Timestamp   `json:"deletedAt"`
	Type       CategoriesTypeEnum `json:"type"`
}

func (q *Queries) UpdateRecord(ctx context.Context, arg UpdateRecordParams) (UpdateRecordRow, error) {
	row := q.db.QueryRow(ctx, updateRecord,
		arg.Amount,
		arg.Comment,
		arg.Timestamp,
		arg.CategoryID,
		arg.ID,
	)
	var i UpdateRecordRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Amount,
		&i.Comment,
		&i.Timestamp,
		&i.CategoryID,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}
